import pytest
from scripts.deploy import deploy_lottery
from scripts.utils import LOCAL_BLOCKCHAIN_ENVIRONMENTS,get_account,fund_with_link,get_contract
from brownie import network,exceptions
from web3 import Web3
import time

ENTRY_FEE = 10
ACTUAL_PRICE_USD_WEI=219137093785000
ACCEPTED_ETHWEI_ERROR=21913709378500
SUPERIOR_COTA=ACTUAL_PRICE_USD_WEI * ENTRY_FEE + ACCEPTED_ETHWEI_ERROR
INFERIOR_COTA=ACTUAL_PRICE_USD_WEI * ENTRY_FEE - ACCEPTED_ETHWEI_ERROR

def test_get_entrance_fee():
    if(network.show_active() not in LOCAL_BLOCKCHAIN_ENVIRONMENTS):
        pytest.skip()
    #Arrange
    lottey=deploy_lottery(ENTRY_FEE)

    #Act
    # 1 ETH = 2000 USD
    # ENTRE_FEE = 5/2000 = 1 / 400 = 0.0025
    expected_entrance_fee=Web3.toWei(ENTRY_FEE/2000,"ether")
    entry_price_in_ETHWEI = lottey.getEntranceFee()

    #Assert
    #assert entry_price_in_ETHWEI<=SUPERIOR_COTA and entry_price_in_ETHWEI>=INFERIOR_COTA
    assert entry_price_in_ETHWEI == expected_entrance_fee
    pass

def test_cant_enter_unless_started():

    if(network.show_active() not in LOCAL_BLOCKCHAIN_ENVIRONMENTS):
        pytest.skip()
    #Arrange
    account= get_account()
    lottery=deploy_lottery(ENTRY_FEE)
    entry_fee=lottery.getEntranceFee()

    #Act/assert
    with pytest.raises(exceptions.VirtualMachineError):
        lottery.enter({"from": account, "value": entry_fee})
    pass

def test_can_enter():

    if(network.show_active() not in LOCAL_BLOCKCHAIN_ENVIRONMENTS):
        pytest.skip()

    #Arrange
    account= get_account()
    lottery=deploy_lottery(ENTRY_FEE)
    lottery.startLottery({"from": account})
    entry_fee=lottery.getEntranceFee()
    

    #Act
    enter_tx = lottery.enter({"from": account, "value": entry_fee})
    enter_tx.wait(1)
    #Assert
    assert lottery.players(0) == account
    pass

def test_end_lottery():
    if(network.show_active() not in LOCAL_BLOCKCHAIN_ENVIRONMENTS):
        pytest.skip()
    
    #Arrange
    account= get_account()
    lottery=deploy_lottery(ENTRY_FEE)
    lottery.startLottery({"from": account})
    entry_fee=lottery.getEntranceFee()

    enter_tx = lottery.enter({"from": account, "value": entry_fee})
    fund_with_link(lottery.address)

    #Act
    end_tx = lottery.endLottery({"from": account})
    end_tx.wait(1)
    assert lottery.lottery_state()==2

    time.sleep(60)
    winner_address= lottery.recentWinner()
    #assert lottery.lottery_state()==1
    #assert winner_address == account.address
    pass

def test_can_pick_winner_correctly():
    if(network.show_active() not in LOCAL_BLOCKCHAIN_ENVIRONMENTS):
        pytest.skip()
        pass
    
    #Arrange
    account= get_account()
    lottery=deploy_lottery(ENTRY_FEE)
    fund_with_link(lottery.address)
    lottery.startLottery({"from": account})
    entry_fee=lottery.getEntranceFee()
    vrf_coordinator = get_contract("vrf-coordinator")
    STATIC_RNG = 777 # "Random" that will be generated by the vrf_coordinator, #0 will be the winner

    #There are 3 participants
    lottery.enter({"from": account, "value": entry_fee}).wait(1)
    lottery.enter({"from": get_account(index=1), "value": entry_fee}).wait(1)
    lottery.enter({"from": get_account(index=2), "value": entry_fee}).wait(1)
    
    
    expected_winner=account
    winner_pot= lottery.balance()
    expected_winner_balance=expected_winner.balance()+winner_pot

    #Act
    end_tx = lottery.endLottery({"from": account})
    end_tx.wait(1)
    request_id=end_tx.events["RequestedRandomness"]["requestId"]
    randomness_tx=vrf_coordinator.callBackWithRandomness(
        request_id,STATIC_RNG,lottery.address,{"from": account}
        )
    randomness_tx.wait(1)
    #time.sleep(60)
    
    winner_address= lottery.recentWinner()

    assert winner_address == expected_winner
    assert expected_winner_balance == expected_winner.balance()
    assert lottery.balance() == 0
    pass